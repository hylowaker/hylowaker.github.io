---
layout: single
title:  "CoreDNS 알아보기"
date:   2023-02-04 12:00:00 +0900
categories: 
tags: Kubernetes
---

[**CoreDNS**](https://coredns.io/)는 DNS 서버이다. 다양한 환경에서 사용 가능하며, 쿠버네티스의 기본 네임 서버로도 채택되었다. 쿠버네티스를 다루다보면 CoreDNS를 맞닥뜨리지 않을 수 없다.

CoreDNS의 특징과 작동 원리에 대해 탐구해보자.


## 특징

왜 쿠버네티스는 CoreDNS를 채택했을까?

- 다양한 작업을 수행하도록 유연하게 구성될 수 있다. 서비스 디스커버리, 요청 재작성, 트래픽 관리 등의 작업을 할 수 있다.
- 고성능, 저지연에 최적화되어 트래픽이 많은 대규모 클러스터에 어울린다.
- 커지는 클러스터에 대응하도록 스케일할 수 있다.
- 오픈 소스이고 개발자 커뮤니티가 활발해 쉽게 확장하고 커스터마이즈할 수 있다.
- 쿠버네티스 클러스터의 리소스 변경 사항을 자동으로 감지하고 DNS 레코드를 업데이트하는 기능이 있다.

(여담인데, 이건 ChatGPT한테 다짜고짜 물어봐서 10초만에 얻은 답이다. 정말로 구글이 위기의식을 느낄 만하다.)

여기서 가장 중요한 것은 **유연성**이다. CoreDNS는 수많은 플러그인이 합쳐져 다양한 기능을 수행할 수 있다. 거기에 원한다면 얼마든지 새로운 플러그인을 추가할 수 있다. Go 언어를 다룰 줄 안다면 직접 플러그인을 개발해 적용할 수도 있다.


## 설치 및 구성

[공식 문서](https://coredns.io/manual/toc/#installation)를 보자.

정말 간단하게도 그냥 바이너리 하나 받으면 끝이다. 이 바이너리에 필요한 플러그인이 전부 포함되어있다.

실행 시 `-conf` 플래그를 줘서 설정 파일을 지정할 수 있다. 설정 파일 작성 방법은 [여기](https://github.com/coredns/coredns#examples)를 참고. 읽어보면 대충 어떤 느낌인지 알 것이다.

설정 파일에는 `{`, `}`로 **서버 블록**(Server Block)이 정의된다. 각각의 서버 블록이 하나의 서버에 대응된다. 서버마다 사용할 플러그인을 따로 지정할 수 있다. 즉, CoreDNS 바이너리 하나를 실행하면 설정에 구성된 서버 블록 개수만큼 논리적으로 여러 개의 서버가 돌아간다고 보면 된다. 문서를 보면 "multiple Servers"라는 표현이 나오는데 이걸 얘기하는 것이다.


## 작동 방식

CoreDNS에서 쿼리를 처리할 때 다음과 같은 일이 수행된다.

1. 서버가 여러 개인 경우, 이 쿼리에 대해 가장 구체적인 Zone을 갖는 서버를 찾는다.  
  (예를 들어 두 서버가 각각 `example.org`, `a.example.org`에 대해 구성되고, 쿼리가 `www.a.example.org`이라면 후자에서 처리한다.)
1. 해당 서버에 대해 구성된 플러그인 체인을 통해 쿼리가 라우트된다. 플러그인의 처리 순서는 `plugin.cfg`에 정의된다.
1. 각 플러그인이 쿼리의 처리 여부를 결정한다. 이 때 다음과 같은 일이 발생할 수 있다.
    1.  쿼리를 처리한다.
    1.  쿼리를 처리하지 않는다.
    1.  쿼리를 처리하지만 체인의 다음 플러그인을 계속 호출한다. 이를 fallthrough라고 한다.
    1.  쿼리를 처리하고 *힌트*를 추가하여 다음 플러그인을 호출한다. 이 힌트는 최종 응답을 확인하고 이에 따른 행동을 할 수 있도록 한다.

> 쿼리를 "처리"한다는 것은 플러그인이 클라이언트에 응답을 보내는 것을 의미한다.


## TODO

작성중

<!-- https://coredns.io/2017/03/01/how-to-add-plugins-to-coredns/ -->


---
### 참고 자료
<https://youtube.com/watch?v=rNlSgYZoIYs>